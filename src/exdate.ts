/*
 * 4.8.5.1 Exception Date/Times

   Property Name: EXDATE

   Purpose: This property defines the list of date/time exceptions for a
   recurring calendar component.

   Value Type: The default value type for this property is DATE-TIME.
   The value type can be set to DATE.

   Property Parameters: Non-standard, value data type and time zone
   identifier property parameters can be specified on this property.

   Conformance: This property can be specified in an iCalendar object
   that includes a recurring calendar component.

   Description: The exception dates, if specified, are used in computing
   the recurrence set. The recurrence set is the complete set of
   recurrence instances for a calendar component. The recurrence set is
   generated by considering the initial "DTSTART" property along with
   the "RRULE", "RDATE", "EXDATE" and "EXRULE" properties contained
   within the iCalendar object. The "DTSTART" property defines the first
   instance in the recurrence set. Multiple instances of the "RRULE" and
   "EXRULE" properties can also be specified to define more
   sophisticated recurrence sets. The final recurrence set is generated
   by gathering all of the start date-times generated by any of the
   specified "RRULE" and "RDATE" properties, and then excluding any
   start date and times which fall within the union of start date and
   times generated by any specified "EXRULE" and "EXDATE" properties.
   This implies that start date and times within exclusion related
   properties (i.e., "EXDATE" and "EXRULE") take precedence over those
   specified by inclusion properties (i.e., "RDATE" and "RRULE"). Where
   duplicate instances are generated by the "RRULE" and "RDATE"
   properties, only one recurrence is considered. Duplicate instances
   are ignored.

   The "EXDATE" property can be used to exclude the value specified in
   "DTSTART". However, in such cases the original "DTSTART" date MUST
   still be maintained by the calendaring and scheduling system because
   the original "DTSTART" value has inherent usage dependencies by other
   properties such as the "RECURRENCE-ID".

   Format Definition: The property is defined by the following notation:

     exdate     = "EXDATE" exdtparam ":" exdtval *("," exdtval) CRLF

     exdtparam  = *(

                ; the following are optional,
                ; but MUST NOT occur more than once

                (";" "VALUE" "=" ("DATE-TIME" / "DATE")) /

                (";" tzidparam) /

                ; the following is optional,
                ; and MAY occur more than once

                (";" xparam)

                )

     exdtval    = date-time / date
     ;Value MUST match value type

   Example: The following is an example of this property:

     EXDATE:19960402T010000Z,19960403T010000Z,19960404T010000Z
*/

import { TimeZoneIdentifier } from "./timezone";
import { XParam } from "./xparam";
import { iCalDate } from "./iCalDate";
import { iCalDatetime } from "./iCalDatetime";
import * as v from "valibot";
import { parseISO } from "date-fns/parseISO";

export class Exdate {
    public value?: "DATE-TIME" | "DATE";
    public timeZone?: TimeZoneIdentifier;
    public xParam?: XParam[]
    public dates: Date[]

    static parse(str: string) {
        return v.parse(ExdateInputSchema, str);
    }

    constructor({ value, timeZone, xParam, date }: ExdateOptions) {
        this.value = value;
        this.timeZone = timeZone;
        this.xParam = xParam
            ? Array.isArray(xParam)
                ? xParam
                : [xParam]
            : undefined;
        this.dates = Array.isArray(date)
            ? date
            : [date]
    }

    toString() {
        return `EXDATE${this.exdtparam}:${this.exdtval}`;
    }

    private get exdtparam() {
        let out = '';
        if (this.value) out += `;VALUE=${this.value}`
        // Ignore; handled in datetime formatting
        // if (this.timeZone) out += `;${this.timeZone}`
        if (this.xParam && this.xParam.length > 0) out += this.xParam.map(xp => `;${xp}`);
        return out;
    }

    private get exdtval() {
        return this.dates
            .map(date => {
                if (this.value === "DATE") return new iCalDate(date);
                let dt = new iCalDatetime(date);
                if (this.timeZone) dt = dt.inTimeZone(this.timeZone);
                return dt;
            })
            .join(',');
    }
}

type ExdateOptions = Partial<{
    value: typeof Exdate.prototype.value;
    timeZone: typeof Exdate.prototype.timeZone;
    xParam: XParam | XParam[];
}> & {
    date: Date | Date[];
}

const ExdateInputSchema = v.pipe(
    v.string(),
    v.regex(/EXDATE.*:.+/),
    v.transform(input => {
        const [before, exdtval] = input.split(':');
        const options = before
            .slice(6)
            .split(';')
            .reduce((agg, param) => {
                if (param.length === 0) return agg;
                const result = v.parse(ExdateParamSchema, param);
                if (!result) return agg;
                if (result instanceof XParam) {
                    agg.xParam.push(result);
                } else if (result instanceof TimeZoneIdentifier) {
                    agg.timeZone = result;
                } else {
                    agg.value = result;
                }
                return agg;
            }, { value: undefined, timeZone: undefined, xParam: [] } as {
                value: typeof Exdate.prototype.value;
                timeZone: typeof Exdate.prototype.timeZone;
                xParam: XParam[];
            });

        const date = exdtval
            .split(',')
            .map(str => parseISO(str));

        return new Exdate({ ...options, date })
    })
)

const ExdateParamSchema = v.pipe(
    v.string(),
    v.transform(input => {
        if (input.startsWith('VALUE')) return v.parse(ExdateValueInputSchema, input);
        if (input.startsWith(TimeZoneIdentifier.paramName)) return TimeZoneIdentifier.parse(input);
        return XParam.parse(input);
    })
)

const ExdateValueInputSchema = v.pipe(
    v.string(),
    v.regex(/VALUE=(DATE|DATE-TIME)$/),
    v.transform(input => input.split('=')[1] as typeof Exdate.prototype.value)
)